#!/usr/bin/env python
#
# A tool to manipulate clouds
#
# Author: Peter Pakos <peter.pakos@wandisco.com>

from __future__ import print_function
import os
import sys
import abc
import argparse
import boto3
import botocore.exceptions
import prettytable
import datetime
import pytz
import tzlocal
import wdmailer


class Main(object):
    _version = '16.4.4'
    _name = os.path.basename(sys.argv[0])

    def __init__(self):
        self._args = self._parse_args()
        self._cloud = Cloud.loader(self._args.cloud_provider, self._args.profile_name, self._args.region)

    def run(self):
        if self._args.command == 'describe-instances':
            self._cloud.describe_instances(disable_border=self._args.disable_border,
                                           disable_header=self._args.disable_header,
                                           state=self._args.state,
                                           notify=self._args.notify)
        elif self._args.command == 'describe-regions':
            self._cloud.describe_regions(disable_border=self._args.disable_border,
                                         disable_header=self._args.disable_header)
        elif self._args.command == 'exclude':
            self._cloud.tag(instance_id=self._args.id,
                            key='EXCLUDE',
                            value='True')
        elif self._args.command == 'include':
            self._cloud.tag(instance_id=self._args.id,
                            key='EXCLUDE',
                            delete=True)
        elif self._args.command == 'tag':
            self._cloud.tag(instance_id=self._args.id,
                            key=self._args.key,
                            value=self._args.value,
                            delete=self._args.delete)
        else:
            self.die('Command %s not implemented yet' % self._args.command)

    def _display_version(self):
        print('%s version %s' % (self._name, self._version))

    @staticmethod
    def die(message=None, code=1):
        if message is not None:
            print(message, file=sys.stderr)
        exit(code)

    def _parse_args(self):
        parser = argparse.ArgumentParser(description='A tool to manipulate clouds')

        parser.add_argument('--version', action='version', version='%s %s' % (self._name, self._version))
        parser.add_argument('-c', '--cloud-provider', help='cloud provider (default: %(default)s)',
                            dest='cloud_provider', choices=['aws', 'gce', 'azure'], default='aws')
        parser.add_argument('-p', '--profile-name', help='cloud profile name (default: %(default)s)',
                            dest='profile_name', default='default')
        parser.add_argument('-r', '--region', help='choose single region (default: all)', dest='region')

        subparsers = parser.add_subparsers(title='commands', dest='command')
        parser_describe_instances = subparsers.add_parser('describe-instances', help='display list of instances')
        parser_describe_instances.add_argument('-b', '--disable-border', help='disable table border',
                                               action='store_true', dest='disable_border')
        parser_describe_instances.add_argument('-H', '--disable-header', help='disable table header',
                                               action='store_true', dest='disable_header')
        parser_describe_instances.add_argument('-s', '--state', help='display instances only in certain states',
                                               action='append', dest='state',
                                               choices=['running', 'pending', 'shutting-down', 'stopped', 'stopping',
                                                        'terminated'])
        parser_describe_instances.add_argument('-n', '--notify', help='send notification and warning emails',
                                               action='store_true', dest='notify')

        parser_describe_regions = subparsers.add_parser('describe-regions', help='display list of available regions')
        parser_describe_regions.add_argument('-b', '--disable-border', help='disable table border',
                                             action='store_true', dest='disable_border')
        parser_describe_regions.add_argument('-H', '--disable-header', help='disable table header',
                                             action='store_true', dest='disable_header')

        parser_exclude = subparsers.add_parser('exclude', help='exclude instances from alerting (create EXCLUDE tag)')
        parser_exclude.add_argument('-i', '--id', help='instance id', action='append', dest='id', required=True)

        parser_include = subparsers.add_parser('include', help='include instances in alerting (delete EXCLUDE tag)')
        parser_include.add_argument('-i', '--id', help='instance id', action='append', dest='id', required=True)

        parser_tag = subparsers.add_parser('tag', help='tag instance')
        parser_tag.add_argument('-i', '--id', help='instance id', action='append', dest='id', required=True)
        parser_tag.add_argument('-k', '--key', help='tag\'s key', dest='key', required=True)
        parser_tag.add_argument('-v', '--value', help='tag\'s value', dest='value', default='')
        parser_tag.add_argument('-d', '--delete', help='delete tag', dest='delete', action='store_true', default=False)

        return parser.parse_args()


class Cloud(object):
    __metaclass__ = abc.ABCMeta

    def __init__(self, cloud_provider, profile_name, region):
        self._cloud_provider = cloud_provider
        self._profile_name = profile_name
        self._region = region
        self._mail = wdmailer.Mail()
        self._warning_threshold = 3600 * 12

    @staticmethod
    def loader(cloud_provider, profile_name, region):
        classes = {'aws': AWS, 'azure': AZURE, 'gce': GCE}
        return classes[cloud_provider](cloud_provider, profile_name, region)

    @abc.abstractmethod
    def describe_instances(self):
        pass

    @abc.abstractmethod
    def describe_regions(self):
        pass


class AWS(Cloud):
    def __init__(self, *args, **kwargs):
        super(AWS, self).__init__(*args, **kwargs)
        self._session = None
        ec2c = None
        try:
            self._session = boto3.Session(profile_name=self._profile_name)
        except botocore.exceptions.ProfileNotFound as err:
            Main.die(err.message)
        try:
            ec2c = self._session.client('ec2')
        except botocore.exceptions.NoRegionError as err:
            print(err.message)
            exit(1)
        self._regions = []
        regions = None
        try:
            regions = ec2c.describe_regions()
        except botocore.exceptions.EndpointConnectionError as err:
            Main.die(err.message)
        except botocore.exceptions.ClientError as err:
            Main.die(err.message)
        for region in regions['Regions']:
            self._regions.append(region['RegionName'])
        if self._region:
            if self._region not in self._regions:
                Main.die('Region must be one of the following:\n- %s' %
                         '\n- '.join(self._regions))
            else:
                self._regions = [self._region]

    @staticmethod
    def _get_tag(list_a, search_key):
        value = None
        if type(list_a) == list:
            for item in list_a:
                if item['Key'] == search_key:
                    value = item['Value']
                    break
        return value

    @staticmethod
    def _date_diff(date1, date2):
        diff = (date1-date2)
        diff = (diff.microseconds + (diff.seconds + diff.days * 24 * 3600) * 10**6) / 10**6
        return diff

    @staticmethod
    def _get_uptime(seconds):
        d = divmod(seconds, 86400)
        h = divmod(d[1], 3600)
        m = divmod(h[1], 60)
        s = m[1]
        uptime = []
        if d[0] > 0:
            uptime.append('%dd' % d[0])
        if h[0] > 0:
            uptime.append('%dh' % h[0])
        if m[0] > 0:
            uptime.append('%dm' % m[0])
        uptime.append('%ds' % s)
        uptime = ' '.join(uptime)
        return uptime

    @staticmethod
    def _get_dept(vpc_name):
        if vpc_name is None:
            return ''
        if vpc_name.startswith('DEV'):
            dept = 'DEV'
        elif vpc_name.startswith('QA'):
            dept = 'QA'
        elif vpc_name.startswith('SALES'):
            dept = 'SALE'
        elif vpc_name.startswith('SUPPORT'):
            dept = 'SUPP'
        else:
            dept = ''
        return dept

    def _send_alert(self, email_type, user, number):
        s = ''
        have = 'has'
        if number > 1:
            s = 's'
            have = 'have'
        sender = 'Infrastructure & IT <infra@wandisco.com>'
        recipient = user + '@wandisco.com'
        if email_type == 'notification':
            subject = 'EC2 running instances'
            message = '''Hi %s,

This is just a friendly reminder that you have %s running EC2 instance%s.

Make sure any running instances are either STOPPED or TERMINATED before close of business.

Please note, any instances running for more than %s hours will be reported to the respective head of department.

Thank you.

--
Infrastructure & IT Team
''' % (user.split('.')[0].capitalize(), number, s, self._warning_threshold/3600)
        elif email_type == 'warning':
            subject = 'WARNING: EC2 running instances'
            message = '''Hi %s,

You currently have %s EC2 instance%s that %s been running for more than %s hours.

Please STOP or TERMINATE any instances that are no longer in use.

Thank you.

--
Infrastructure & IT Team
''' % (user.split('.')[0].capitalize(), number, s, have, self._warning_threshold/3600)
        else:
            print('Unknown email type: %s' % email_type)
            return
        print('Sending %s email to %s... ' % (email_type, recipient), end='')
        status, msg = self._mail.send(sender, recipient, subject, message)
        print(msg['message'])

    def describe_instances(self, disable_border=False, disable_header=False, state=None, notify=False):
        if not state:
            state = ['running', 'pending', 'shutting-down', 'stopped', 'stopping', 'terminated']
        table = prettytable.PrettyTable(['Zone', 'Dept', 'ID', 'Name', 'Type', 'Image', 'State',
                                         'Launch time', 'Uptime', 'Last user', 'SSH key', 'Private IP', 'Public IP',
                                         'Exclude'],
                                        border=not disable_border, header=not disable_header, reversesort=True,
                                        sortby='Launch time')
        table.align = 'l'
        i = 0
        states = dict()
        notify_list = dict()
        warning_list = dict()
        local_tz = tzlocal.get_localzone()
        now = local_tz.localize(datetime.datetime.now())
        for region in self._regions:
            ec2r = self._session.resource('ec2', region_name=region)
            instances = ec2r.instances.filter(Filters=[{
                'Name': 'instance-state-name',
                'Values': state
            }])
            for instance in instances:
                i += 1
                dept = ''
                excluded = False
                if self._get_tag(instance.tags, 'EXCLUDE') is not None:
                    excluded = True
                if instance.vpc_id is not None:
                    vpc_id = instance.vpc_id
                    vpc = ec2r.Vpc(vpc_id)
                    dept = self._get_dept(self._get_tag(vpc.tags, 'Name'))
                image_name = ''
                instance_state = instance.state['Name']
                last_user = self._get_tag(instance.tags, 'Last_user') or ''
                uptime = ''
                name = self._get_tag(instance.tags, 'Name')
                then = instance.launch_time.astimezone(pytz.timezone(str(local_tz)))
                launch_time = str(then).partition('+')[0]
                if instance_state == 'running':
                    seconds = self._date_diff(now, then)
                    uptime = self._get_uptime(seconds)
                    if last_user:
                        if notify and not excluded and seconds < self._warning_threshold:
                            if last_user in notify_list:
                                notify_list[last_user] += 1
                            else:
                                notify_list[last_user] = 1
                        if notify and not excluded and seconds >= self._warning_threshold:
                            if last_user in warning_list:
                                warning_list[last_user] += 1
                            else:
                                warning_list[last_user] = 1
                try:
                    image_name = instance.image.name[0:15]
                except AttributeError:
                    pass
                table.add_row([
                    instance.placement['AvailabilityZone'],
                    dept,
                    instance.id,
                    name,
                    instance.instance_type,
                    image_name,
                    instance_state,
                    launch_time,
                    uptime,
                    last_user,
                    instance.key_name,
                    instance.private_ip_address,
                    instance.public_ip_address,
                    excluded
                ])
                if instance.state['Name'] in states:
                    states[instance.state['Name']] += 1
                else:
                    states[instance.state['Name']] = 1
        print(table)
        out = ', '.join(['%s: %s' % (key, value) for (key, value) in sorted(states.items())])
        if len(out) > 0:
            out = '(%s)' % out
        else:
            out = ''
        print('Time: %s (%s) | Instances: %s %s' % (now.strftime('%Y-%m-%d %H:%M:%S'), str(local_tz), i, out))
        for user in warning_list:
            if user in notify_list:
                notify_list.pop(user)
        if len(warning_list) > 0 or len(notify_list) > 0:
            print()
        for user in notify_list:
            self._send_alert('notification', user, notify_list[user])
        for user in warning_list:
            self._send_alert('warning', user, warning_list[user])

    def describe_regions(self, disable_border=False, disable_header=False):
        table = prettytable.PrettyTable(['Region'], border=not disable_border, header=not disable_header,
                                        sortby='Region')
        table.align = 'l'
        for region in self._regions:
            table.add_row([region])
        print(table)

    def _create_tag(self, region, resource, key, value):
        ec2c = self._session.client('ec2', region_name=region)
        ec2c.create_tags(Resources=[resource], Tags=[{
            'Key': key,
            'Value': value
        }])
        return True

    def _delete_tag(self, region, resource, key):
        ec2c = self._session.client('ec2', region_name=region)
        ec2c.delete_tags(Resources=[resource], Tags=[{
            'Key': key
        }])
        return True

    def tag(self, instance_id, key, value='', delete=False):
        i = 0
        for region in self._regions:
            ec2r = self._session.resource('ec2', region_name=region)
            instances = ec2r.instances.filter(Filters=[{
                'Name': 'instance-state-name',
                'Values': ['running', 'pending', 'shutting-down', 'stopped', 'stopping', 'terminated']
            }])
            for instance in instances:
                if instance.id in instance_id:
                    i += 1
                    if delete:
                        print('Instance ID %s found in region %s, deleting tag \'%s\': ' % (instance.id, region, key),
                              end='')
                        response = self._delete_tag(region=region, resource=instance.id, key=key)
                    else:
                        print('Instance ID %s found in region %s, creating tag \'%s\': ' % (instance.id, region, key),
                              end='')
                        response = self._create_tag(region=region, resource=instance.id, key=key, value=value)
                    if response:
                        print('OK')
                    else:
                        print('FAIL')
                    if len(instance_id) == i:
                        return
        if i == 0:
            if self._region:
                region = 'region ' + self._region
            else:
                region = 'any region'
            print('Instance ID %s not found in %s' % (', '.join(instance_id), region))


class AZURE(Cloud):
    def __init__(self, *args, **kwargs):
        super(AZURE, self).__init__(*args, **kwargs)
        Main.die('%s module not implemented yet, exiting...' % self._cloud_provider.upper())

    def describe_instances(self):
        pass

    def describe_regions(self):
        pass


class GCE(Cloud):
    def __init__(self, *args, **kwargs):
        super(GCE, self).__init__(*args, **kwargs)
        Main.die('%s module not implemented yet, exiting...' % self._cloud_provider.upper())

    def describe_instances(self):
        pass

    def describe_regions(self):
        pass


if __name__ == '__main__':
    try:
        main = Main()
        main.run()
    except KeyboardInterrupt:
        print('\nCancelling...')
